# Node架构设计

## 设计原则

基于**奥卡姆剃刀原则**，我们设计了一个最简单但通用的Node结构，可以适应不同的场景和任务。

## Node统一结构

每个Persona都是一个独立的Node，所有Node使用统一的结构：

```json
{
  "meta": {
    "id": "node_001",
    "name": "甲方Persona",
    "role": "60岁奢侈品眼镜买手 + 美术教授",
    "type": "reviewer",
    "version": "1.0.0"
  },
  
  "input": {
    "description": "这个Node接收什么输入",
    "schema": {
      // 输入数据的格式（可选，不限定具体格式）
    }
  },
  
  "process": {
    "prompt": "这个Node要做什么（自然语言描述）",
    "rules": [
      "规则1：品牌必须是制造商品牌",
      "规则2：识别率必须达到95%+",
      "规则3：..."
    ],
    "context": {
      // 这个Node需要的上下文信息
      "brand_dictionary": "品牌字典路径",
      "historical_feedback": "历史反馈路径"
    }
  },
  
  "output": {
    "description": "这个Node输出什么",
    "schema": {
      // 输出数据的格式（可选）
    }
  },
  
  "feedback": {
    "to": ["node_002", "node_003"],
    "condition": "什么条件触发反馈",
    "action": "反馈后做什么"
  }
}
```

## 字段说明

### meta（元信息）
定义Node的基本信息：
- **id**: Node的唯一标识符
- **name**: Node的名称（人类可读）
- **role**: Node的角色描述
- **type**: Node的类型（executor执行者 / reviewer评审者 / coordinator协调者）
- **version**: Node的版本号

### input（输入）
定义Node接收什么数据：
- **description**: 输入的描述（自然语言）
- **schema**: 输入数据的格式（可选，JSON Schema格式）

**设计理念**：不限定具体格式，保持灵活性，适应不同场景。

### process（处理）
定义Node如何处理数据：
- **prompt**: 用自然语言描述这个Node要做什么
- **rules**: 这个Node遵循的规则和标准（数组）
- **context**: 这个Node需要的上下文信息（如品牌字典、历史反馈等）

**设计理念**：用自然语言描述处理逻辑，而不是写死的代码，保持可读性和可维护性。

### output（输出）
定义Node输出什么数据：
- **description**: 输出的描述（自然语言）
- **schema**: 输出数据的格式（可选，JSON Schema格式）

**设计理念**：不限定具体格式，可以是数据、报告、评分、建议等任何形式。

### feedback（反馈循环）
定义Node如何与其他Node协作：
- **to**: 输出给哪些Node（Node ID数组）
- **condition**: 什么条件触发反馈（自然语言描述）
- **action**: 反馈后做什么（自然语言描述）

**设计理念**：定义Node之间的连接关系，形成协作网络。

## Node类型

### executor（执行者）
负责执行具体任务，如数据清洗、品牌识别、型号提取等。

**特点**：
- 输入：原始数据
- 输出：处理后的数据
- 反馈：接收评审者的反馈，优化算法

**示例**：小M（数据清洗执行者）

### reviewer（评审者）
负责评审执行者的输出，提出问题和建议。

**特点**：
- 输入：执行者的输出
- 输出：评审报告、评分、改进建议
- 反馈：将建议反馈给执行者或协调者

**示例**：甲方Persona、5个专家Persona

### coordinator（协调者）
负责协调多个Node的协作，整合反馈，制定改进计划。

**特点**：
- 输入：多个Node的输出
- 输出：综合报告、优先级排序、改进计划
- 反馈：将改进计划分发给相关Node

**示例**：小M（也承担协调者角色）

## Node协作模式

### 串行模式
Node按顺序执行，前一个Node的输出是后一个Node的输入。

```
Node A → Node B → Node C
```

### 并行模式
多个Node同时执行，处理相同的输入。

```
        → Node B →
Node A  → Node C  → Node E
        → Node D →
```

### 反馈循环模式
Node之间形成反馈循环，不断迭代优化。

```
Node A → Node B → Node A → Node B → ...
```

## 实际应用示例

### 数据清洗场景

**Node 1: 小M（执行者）**
- 输入：原始商品数据
- 处理：数据清洗、品牌识别、型号提取
- 输出：清洗后的数据 + 质量报告
- 反馈：接收6个评审者的反馈，优化算法

**Node 2-7: 6个Persona（评审者）**
- 输入：清洗后的数据 + 质量报告
- 处理：从各自的角度评审数据质量
- 输出：评审报告 + 评分 + 改进建议
- 反馈：将建议反馈给小M

**协作流程：**
1. 小M执行数据清洗
2. 6个Persona并行评审
3. 小M整合反馈，优化算法
4. 重新执行清洗，重新评审
5. 循环直到达到质量标准

## 扩展性

### 添加新的Node
只需创建一个新的Node配置文件，定义它的meta、input、process、output、feedback即可。

### 修改现有Node
只需修改Node配置文件中的相应字段，不影响其他Node。

### 组合不同的Node
通过修改feedback字段，可以灵活组合不同的Node，形成不同的协作模式。

## 泛用性

这个Node架构不仅适用于数据清洗场景，还可以应用于：
- 内容创作（写作者 + 编辑者 + 审核者）
- 产品设计（设计者 + 评审者 + 用户测试者）
- 决策支持（分析者 + 专家 + 决策者）
- 任何需要多角色协作的场景

**核心理念**：用统一的结构描述不同的角色和任务，通过组合和连接形成智能系统。
